<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>HTTPS 和 TLS | 扎星的博客</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="Just playing around">
    
    <link rel="preload" href="/assets/css/0.styles.b0fbd704.css" as="style"><link rel="preload" href="/assets/js/app.7faaeb90.js" as="script"><link rel="preload" href="/assets/js/2.4ceac094.js" as="script"><link rel="preload" href="/assets/js/1.06e97743.js" as="script"><link rel="preload" href="/assets/js/26.b6ea8fe3.js" as="script"><link rel="prefetch" href="/assets/js/10.4d67db37.js"><link rel="prefetch" href="/assets/js/100.9ada27ad.js"><link rel="prefetch" href="/assets/js/101.7eccfd40.js"><link rel="prefetch" href="/assets/js/102.e344b695.js"><link rel="prefetch" href="/assets/js/103.b91c2e2b.js"><link rel="prefetch" href="/assets/js/104.6f90f799.js"><link rel="prefetch" href="/assets/js/105.73780a6e.js"><link rel="prefetch" href="/assets/js/106.e8737813.js"><link rel="prefetch" href="/assets/js/107.5f785c2c.js"><link rel="prefetch" href="/assets/js/108.74958d5b.js"><link rel="prefetch" href="/assets/js/109.d3005515.js"><link rel="prefetch" href="/assets/js/11.32340e89.js"><link rel="prefetch" href="/assets/js/110.65860f7f.js"><link rel="prefetch" href="/assets/js/111.d91c32b6.js"><link rel="prefetch" href="/assets/js/112.a5e8efc2.js"><link rel="prefetch" href="/assets/js/113.191ff9e1.js"><link rel="prefetch" href="/assets/js/114.eb21d1d8.js"><link rel="prefetch" href="/assets/js/115.ed058567.js"><link rel="prefetch" href="/assets/js/116.c73d4a79.js"><link rel="prefetch" href="/assets/js/117.c1195019.js"><link rel="prefetch" href="/assets/js/118.b2aeca16.js"><link rel="prefetch" href="/assets/js/119.666dc6c6.js"><link rel="prefetch" href="/assets/js/12.f3209147.js"><link rel="prefetch" href="/assets/js/120.548bb39a.js"><link rel="prefetch" href="/assets/js/121.d6368bb6.js"><link rel="prefetch" href="/assets/js/122.14d59fae.js"><link rel="prefetch" href="/assets/js/123.7e5e4cc0.js"><link rel="prefetch" href="/assets/js/124.a9c9fc37.js"><link rel="prefetch" href="/assets/js/125.2de4a8c4.js"><link rel="prefetch" href="/assets/js/126.6d029a58.js"><link rel="prefetch" href="/assets/js/127.3f37c3d9.js"><link rel="prefetch" href="/assets/js/128.3bab5bc7.js"><link rel="prefetch" href="/assets/js/129.fde4fcbb.js"><link rel="prefetch" href="/assets/js/13.ff905545.js"><link rel="prefetch" href="/assets/js/130.21002715.js"><link rel="prefetch" href="/assets/js/131.e261ff32.js"><link rel="prefetch" href="/assets/js/132.f4df11c1.js"><link rel="prefetch" href="/assets/js/133.3082ed5c.js"><link rel="prefetch" href="/assets/js/134.f583893d.js"><link rel="prefetch" href="/assets/js/135.4930a3bf.js"><link rel="prefetch" href="/assets/js/136.088fe073.js"><link rel="prefetch" href="/assets/js/137.3b78020c.js"><link rel="prefetch" href="/assets/js/138.19b200da.js"><link rel="prefetch" href="/assets/js/139.890d6075.js"><link rel="prefetch" href="/assets/js/14.c3568dfc.js"><link rel="prefetch" href="/assets/js/140.5b795da9.js"><link rel="prefetch" href="/assets/js/141.15c2c5e7.js"><link rel="prefetch" href="/assets/js/142.c336f1c2.js"><link rel="prefetch" href="/assets/js/143.0eba62e9.js"><link rel="prefetch" href="/assets/js/144.556773e6.js"><link rel="prefetch" href="/assets/js/15.7af482c3.js"><link rel="prefetch" href="/assets/js/16.1add91f2.js"><link rel="prefetch" href="/assets/js/17.5211db13.js"><link rel="prefetch" href="/assets/js/18.cb58294e.js"><link rel="prefetch" href="/assets/js/19.3f4c86e4.js"><link rel="prefetch" href="/assets/js/20.f6e9413a.js"><link rel="prefetch" href="/assets/js/21.d3127fc5.js"><link rel="prefetch" href="/assets/js/22.75a3675d.js"><link rel="prefetch" href="/assets/js/23.4cc8500e.js"><link rel="prefetch" href="/assets/js/24.6e9f6fde.js"><link rel="prefetch" href="/assets/js/25.59ab9b92.js"><link rel="prefetch" href="/assets/js/27.eb622419.js"><link rel="prefetch" href="/assets/js/28.82216df1.js"><link rel="prefetch" href="/assets/js/29.aca5231f.js"><link rel="prefetch" href="/assets/js/3.cc8f990c.js"><link rel="prefetch" href="/assets/js/30.b0c74906.js"><link rel="prefetch" href="/assets/js/31.41b824b5.js"><link rel="prefetch" href="/assets/js/32.95d89f8c.js"><link rel="prefetch" href="/assets/js/33.7387a515.js"><link rel="prefetch" href="/assets/js/34.3fa9be34.js"><link rel="prefetch" href="/assets/js/35.905a5d0a.js"><link rel="prefetch" href="/assets/js/36.d7ce4b9a.js"><link rel="prefetch" href="/assets/js/37.fd8aaeb0.js"><link rel="prefetch" href="/assets/js/38.b36232f9.js"><link rel="prefetch" href="/assets/js/39.ae371aa8.js"><link rel="prefetch" href="/assets/js/4.b6f813b6.js"><link rel="prefetch" href="/assets/js/40.9e77645d.js"><link rel="prefetch" href="/assets/js/41.7aced1a6.js"><link rel="prefetch" href="/assets/js/42.3431685d.js"><link rel="prefetch" href="/assets/js/43.3c61b623.js"><link rel="prefetch" href="/assets/js/44.74706cc8.js"><link rel="prefetch" href="/assets/js/45.6deb7af6.js"><link rel="prefetch" href="/assets/js/46.51a84a36.js"><link rel="prefetch" href="/assets/js/47.446a6488.js"><link rel="prefetch" href="/assets/js/48.eeb843b8.js"><link rel="prefetch" href="/assets/js/49.f35e84a6.js"><link rel="prefetch" href="/assets/js/5.6c42c548.js"><link rel="prefetch" href="/assets/js/50.39dc3799.js"><link rel="prefetch" href="/assets/js/51.2e98eda6.js"><link rel="prefetch" href="/assets/js/52.0ebf3a07.js"><link rel="prefetch" href="/assets/js/53.7fbd54a4.js"><link rel="prefetch" href="/assets/js/54.42c54b92.js"><link rel="prefetch" href="/assets/js/55.1c372827.js"><link rel="prefetch" href="/assets/js/56.3db642d3.js"><link rel="prefetch" href="/assets/js/57.385f3c0e.js"><link rel="prefetch" href="/assets/js/58.fcb950f6.js"><link rel="prefetch" href="/assets/js/59.b77c39f3.js"><link rel="prefetch" href="/assets/js/6.249f79ed.js"><link rel="prefetch" href="/assets/js/60.4e20518b.js"><link rel="prefetch" href="/assets/js/61.86f57283.js"><link rel="prefetch" href="/assets/js/62.a4fe965c.js"><link rel="prefetch" href="/assets/js/63.c5dbf72b.js"><link rel="prefetch" href="/assets/js/64.f9242d96.js"><link rel="prefetch" href="/assets/js/65.63c88e9b.js"><link rel="prefetch" href="/assets/js/66.fa97a8fa.js"><link rel="prefetch" href="/assets/js/67.9de0f89d.js"><link rel="prefetch" href="/assets/js/68.3959d250.js"><link rel="prefetch" href="/assets/js/69.8d33bb82.js"><link rel="prefetch" href="/assets/js/7.965b9c14.js"><link rel="prefetch" href="/assets/js/70.eae11422.js"><link rel="prefetch" href="/assets/js/71.9dcc9639.js"><link rel="prefetch" href="/assets/js/72.d9858851.js"><link rel="prefetch" href="/assets/js/73.1f5d46fd.js"><link rel="prefetch" href="/assets/js/74.55cfc98d.js"><link rel="prefetch" href="/assets/js/75.1c8f9b5f.js"><link rel="prefetch" href="/assets/js/76.9712797a.js"><link rel="prefetch" href="/assets/js/77.fc4c4708.js"><link rel="prefetch" href="/assets/js/78.9e58022f.js"><link rel="prefetch" href="/assets/js/79.8958c264.js"><link rel="prefetch" href="/assets/js/80.25f206a9.js"><link rel="prefetch" href="/assets/js/81.82b297fd.js"><link rel="prefetch" href="/assets/js/82.95a92348.js"><link rel="prefetch" href="/assets/js/83.1d856c8a.js"><link rel="prefetch" href="/assets/js/84.2fe27c01.js"><link rel="prefetch" href="/assets/js/85.119d769d.js"><link rel="prefetch" href="/assets/js/86.dda9549d.js"><link rel="prefetch" href="/assets/js/87.5f96db0f.js"><link rel="prefetch" href="/assets/js/88.09fc8a79.js"><link rel="prefetch" href="/assets/js/89.86b4ddcb.js"><link rel="prefetch" href="/assets/js/90.85df2a8a.js"><link rel="prefetch" href="/assets/js/91.593d62b4.js"><link rel="prefetch" href="/assets/js/92.1f4f1612.js"><link rel="prefetch" href="/assets/js/93.3cf32b8f.js"><link rel="prefetch" href="/assets/js/94.ddb588cb.js"><link rel="prefetch" href="/assets/js/95.850c9613.js"><link rel="prefetch" href="/assets/js/96.5e20d25c.js"><link rel="prefetch" href="/assets/js/97.41935f73.js"><link rel="prefetch" href="/assets/js/98.9c3b2db4.js"><link rel="prefetch" href="/assets/js/99.6c498302.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.4849e3bc.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b0fbd704.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">扎星的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTML</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>CSS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JS基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JS数组</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JS编程练习题</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JS常见设计模式</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JS高阶</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>ES6新特性</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>性能优化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>浏览器安全</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>V8引擎</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>异步I/O和异步编程</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>TCP协议</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>HTTP协议</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/networkprotocol/http/001/" class="sidebar-link">http 的报文结构</a></li><li><a href="/networkprotocol/http/002/" class="sidebar-link">http 的请求方法</a></li><li><a href="/networkprotocol/http/003/" class="sidebar-link">如何理解 URI</a></li><li><a href="/networkprotocol/http/004/" class="sidebar-link">http 状态码</a></li><li><a href="/networkprotocol/http/005/" class="sidebar-link">http 协议有哪些特点和缺点</a></li><li><a href="/networkprotocol/http/006/" class="sidebar-link">accept 系列字段解析</a></li><li><a href="/networkprotocol/http/007/" class="sidebar-link">对于定长和不定长的数据，HTTP 是怎么传输的？</a></li><li><a href="/networkprotocol/http/008/" class="sidebar-link">HTTP 如何处理大文件的传输？</a></li><li><a href="/networkprotocol/http/009/" class="sidebar-link">HTTP 中如何处理表单数据的提交？</a></li><li><a href="/networkprotocol/http/010/" class="sidebar-link">HTTP1.1 如何解决 HTTP 的队头阻塞问题？</a></li><li><a href="/networkprotocol/http/011/" class="sidebar-link">如何理解 HTTP 代理？</a></li><li><a href="/networkprotocol/http/012/" aria-current="page" class="active sidebar-link">HTTPS 和 TLS</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/networkprotocol/http/012/#传统-rsa-握手" class="sidebar-link">传统 RSA 握手</a></li><li class="sidebar-sub-header"><a href="/networkprotocol/http/012/#tls-1-2-握手过程" class="sidebar-link">TLS 1.2 握手过程</a></li><li class="sidebar-sub-header"><a href="/networkprotocol/http/012/#rsa-和-ecdhe-握手过程的区别" class="sidebar-link">RSA 和 ECDHE 握手过程的区别</a></li><li class="sidebar-sub-header"><a href="/networkprotocol/http/012/#tls-1-3-做了哪些改进" class="sidebar-link">TLS 1.3 做了哪些改进？</a></li><li class="sidebar-sub-header"><a href="/networkprotocol/http/012/#参考" class="sidebar-link">参考</a></li></ul></li><li><a href="/networkprotocol/http/013/" class="sidebar-link">HTTP2</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>React</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Nodejs</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Webpack</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>typescript</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="https-和-tls"><a href="#https-和-tls" class="header-anchor">#</a> HTTPS 和 TLS</h1> <p>之前谈到了 HTTP 是明文传输的协议，传输保文对外完全透明，非常不安全，那如何进一步保证安全性呢？</p> <p>由此产生了 HTTPS，其实它并不是一个新的协议，而是在 HTTP 下面增加了一层 SSL/TLS 协议，简单的讲，HTTPS = HTTP + SSL/TLS。</p> <h3 id="那什么是-ssl-tls-呢"><a href="#那什么是-ssl-tls-呢" class="header-anchor">#</a> 那什么是 SSL/TLS 呢？</h3> <p>SSL 即安全套接层（Secure Sockets Layer），在 OSI 七层模型中处于会话层(第 5 层)。之前 SSL 出过三个大版本，当它发展到第三个大版本的时候才被标准化，成为 TLS（传输层安全，Transport Layer Security），并被当做 TLS1.0 的版本，准确地说，TLS1.0 = SSL3.1。</p> <p>现在主流的版本是 TLS/1.2, 之前的 TLS1.0、TLS1.1 都被认为是不安全的，在不久的将来会被完全淘汰。因此我们接下来主要讨论的是 TLS1.2, 当然在 2018 年推出了更加优秀的 TLS1.3，大大优化了 TLS 握手过程，这个我们放在下一节再去说。</p> <p>TLS 握手的过程比较复杂，写文章之前我查阅了大量的资料，发现对 TLS 初学者非常不友好，也有很多知识点说的含糊不清，可以说这个整理的过程是相当痛苦了。希望我下面的拆解能够帮你理解得更顺畅些吧 : ）</p> <h2 id="传统-rsa-握手"><a href="#传统-rsa-握手" class="header-anchor">#</a> 传统 RSA 握手</h2> <p>谈到HTTPS, 就不得不谈到与之相对的HTTP。HTTP的特性是明文传输，因此在传输的每一个环节，数据都有可能被第三方窃取或者篡改，具体来说，HTTP 数据经过 TCP 层，然后经过WIFI路由器、运营商和目标服务器，这些环节中都可能被中间人拿到数据并进行篡改，也就是我们常说的中间人攻击(HTTPS也会遭遇中间人攻击)。</p> <p>为了防范这样一类攻击，我们不得已要引入新的加密方案，即 HTTPS。</p> <p>HTTPS并不是一个新的协议, 而是一个加强版的HTTP。其原理是在HTTP和TCP之间建立了一个中间层，当HTTP和TCP通信时并不是像以前那样直接通信，直接经过了一个中间层进行加密，将加密后的数据包传给TCP, 响应的，TCP必须将数据包解密，才能传给上面的HTTP。这个中间层也叫安全层。安全层的核心就是对数据加解密。</p> <h3 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="header-anchor">#</a> 对称加密和非对称加密</h3> <p>首先需要理解对称加密和非对称加密的概念，然后讨论两者应用后的效果如何。</p> <p>对称加密是最简单的方式，指的是加密和解密用的是同样的密钥。</p> <p>而对于非对称加密，如果有 A、 B 两把密钥，如果用 A 加密过的数据包只能用 B 解密，反之，如果用 B 加密过的数据包只能用 A 解密。</p> <h3 id="加解密过程"><a href="#加解密过程" class="header-anchor">#</a> 加解密过程</h3> <p>接着我们来谈谈浏览器和服务器进行协商加解密的过程。</p> <p>首先，浏览器会给服务器发送一个随机数client_random 和一个加密的方法列表。</p> <p>服务器接收后给浏览器返回另一个随机数server_random和加密方法。</p> <p>现在，两者拥有三样相同的凭证: client_random、server_random和加密方法。</p> <p>接着用这个加密方法将两个随机数混合起来生成密钥，这个密钥就是浏览器和服务端通信的暗号。</p> <h3 id="各自应用的效果"><a href="#各自应用的效果" class="header-anchor">#</a> 各自应用的效果</h3> <p>如果用对称加密的方式，那么第三方可以在中间获取到client_random、server_random和加密方法，由于这个加密方法同时可以解密，所以中间人可以成功对暗号进行解密，拿到数据，很容易就将这种加密方式破解了。</p> <p>那能不能只用非对称加密呢？理论上是可以的，但实际上非对称加密需要的计算量非常大，对于稍微大一点的数据即使用最快的处理器也非常耗时。后面有机会给大家分享一下 RSA 非对称加密算法的原理，大家就会有更加直观的认识，这里我们先不深究。</p> <h3 id="对称加密和非对称加密的结合"><a href="#对称加密和非对称加密的结合" class="header-anchor">#</a> 对称加密和非对称加密的结合</h3> <p>可以发现，对称加密和非对称加密，只用前者会有安全隐患，只用后者性能消耗又太大。那我们能不能把两者结合，保证性能的同时又能保证安全呢？</p> <p>其实是可以的，演示一下整个流程：</p> <ol><li><p>浏览器向服务器发送client_random和加密方法列表。</p></li> <li><p>服务器接收到，返回server_random、加密方法以及公钥。</p></li> <li><p>浏览器接收，接着生成另一个随机数pre_random, 并且用公钥加密，传给服务器。(敲黑板！重点操作！)</p></li> <li><p>服务器用私钥解密这个被加密后的pre_random。</p></li> <li><p>现在浏览器和服务器有三样相同的凭证:client_random、server_random和pre_random。然后两者用相同的加密方法混合这三个随机数，生成最终的密钥。</p></li></ol> <p>现在浏览器和服务器有三样相同的凭证:client_random、server_random和pre_random。然后两者用相同的加密方法混合这三个随机数，生成最终的密钥。</p> <p>然后浏览器和服务器尽管用一样的密钥进行通信，即使用对称加密。</p> <p>这个最终的密钥是很难被中间人拿到的，为什么呢? 因为中间人没有私钥，从而拿不到pre_random，也就无法生成最终的密钥了。</p> <p>回头比较一下和单纯的使用非对称加密, 这种方式做了什么改进呢？本质上是防止了私钥加密的数据外传。单独使用非对称加密，最大的漏洞在于服务器传数据给浏览器只能用私钥加密，这是危险产生的根源。利用对称和非对称加密结合的方式，就防止了这一点，从而保证了安全。</p> <h3 id="添加数字证书"><a href="#添加数字证书" class="header-anchor">#</a> 添加数字证书</h3> <p>尽管通过两者加密方式的结合，能够很好地实现加密传输，但实际上还是存在一些问题。黑客如果采用 DNS 劫持，将目标地址替换成黑客服务器的地址，然后黑客自己造一份公钥和私钥，照样能进行数据传输。而对于浏览器用户而言，他是不知道自己正在访问一个危险的服务器的。</p> <p>事实上HTTPS在上述结合对称和非对称加密的基础上，又添加了数字证书认证的步骤。其目的就是让服务器证明自己的身份。</p> <h4 id="传输过程"><a href="#传输过程" class="header-anchor">#</a> 传输过程</h4> <p>为了获取这个证书，服务器运营者需要向第三方认证机构获取授权，这个第三方机构也叫CA(Certificate Authority), 认证通过后 CA 会给服务器颁发数字证书。</p> <p>这个数字证书有两个作用:</p> <ol><li><p>服务器向浏览器证明自己的身份。</p></li> <li><p>把公钥传给浏览器。</p></li></ol> <p>这个验证的过程发生在什么时候呢？</p> <p>当服务器传送server_random、加密方法的时候，顺便会带上数字证书(包含了公钥), 接着浏览器接收之后就会开始验证数字证书。如果验证通过，那么后面的过程照常进行，否则拒绝执行。</p> <p>现在我们来梳理一下HTTPS最终的加解密过程:</p> <p><img src="/assets/img/1.68d466b7.jpg" alt="1"></p> <h4 id="认证过程-证书的签发过程"><a href="#认证过程-证书的签发过程" class="header-anchor">#</a> 认证过程（证书的签发过程）</h4> <p>a.服务方 S 向第三方机构CA提交公钥、组织信息、个人信息(域名)等信息并申请认证；</p> <p>b.CA 通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等；</p> <p>c.如信息审核通过，CA 会向申请者签发认证文件-证书。</p> <p>证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA 的信息、有效时间、证书序列号等信息的明文，同时包含一个签名；</p> <p>签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA 的私钥对信息摘要进行加密，密文即签名；</p> <p>d.客户端 C 向服务器 S 发出请求时，S 返回证书文件；</p> <p>e.客户端 C 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA 的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即公钥合法；</p> <p>f.客户端然后验证证书相关的域名信息、有效时间等信息；</p> <p>g.客户端会内置信任 CA 的证书信息(包含公钥)，如果CA不被信任，则找不到对应 CA 的证书，证书也会被判定非法。</p> <p>在这个过程注意几点：</p> <p>1.申请证书不需要提供私钥，确保私钥永远只能服务器掌握；</p> <p>2.证书的合法性仍然依赖于非对称加密算法，证书主要是增加了服务器信息以及签名；</p> <p>3.内置 CA 对应的证书称为根证书，颁发者和使用者相同，自己为自己签名，即自签名证书；</p> <p>4.证书=公钥+申请者与颁发者信息+签名；</p> <p>注：CA机构用私钥加密证书的摘要生成签名，然后客户端采用 CA 的公钥解密签名，与客户端利用hash计算证书的摘要进行比对，若相同则表示证书未被串改。</p> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <p>HTTPS并不是一个新的协议, 它在HTTP和TCP的传输中建立了一个安全层，利用对称加密和非对称机密结合数字证书认证的方式，让传输过程的安全性大大提高。</p> <h2 id="tls-1-2-握手过程"><a href="#tls-1-2-握手过程" class="header-anchor">#</a> TLS 1.2 握手过程</h2> <p>现在我们来讲讲主流的 TLS 1.2 版本所采用的方式。</p> <p><img src="/assets/img/2.5303dab1.jpg" alt="1"></p> <p>刚开始你可能会比较懵，先别着急，过一遍下面的流程再来看会豁然开朗。</p> <h3 id="step-1-client-hello"><a href="#step-1-client-hello" class="header-anchor">#</a> step 1: Client Hello</h3> <p>首先，浏览器发送 client_random、TLS版本、加密套件列表。</p> <p>client_random 是什么？用来最终 secret 的一个参数。</p> <p>加密套件列表是什么？我举个例子，加密套件列表一般张这样:</p> <div class="language- extra-class"><pre class="language-text"><code>TLS_ECDHE_WITH_AES_128_GCM_SHA256
</code></pre></div><p>意思是TLS握手过程中，使用ECDHE算法生成pre_random(这个数后面会介绍)，128位的AES算法进行对称加密，在对称加密的过程中使用主流的GCM分组模式，因为对称加密中很重要的一个问题就是如何分组。最后一个是哈希摘要算法，采用SHA256算法。</p> <p>其中值得解释一下的是这个哈希摘要算法，试想一个这样的场景，服务端现在给客户端发消息来了，客户端并不知道此时的消息到底是服务端发的，还是中间人伪造的消息呢？现在引入这个哈希摘要算法，将服务端的证书信息通过这个算法生成一个摘要(可以理解为比较短的字符串)，用来标识这个服务端的身份，用私钥加密后把加密后的标识和自己的公钥传给客户端。客户端拿到这个公钥来解密，生成另外一份摘要。两个摘要进行对比，如果相同则能确认服务端的身份。这也就是所谓数字签名的原理。其中除了哈希算法，最重要的过程是私钥加密，公钥解密。</p> <h3 id="step-2-server-hello"><a href="#step-2-server-hello" class="header-anchor">#</a> step 2: Server Hello</h3> <p>可以看到服务器一口气给客户端回复了非常多的内容。</p> <p>server_random也是最后生成secret的一个参数, 同时确认 TLS 版本、需要使用的加密套件和自己的证书，这都不难理解。那剩下的server_params是干嘛的呢？</p> <p>我们先埋个伏笔，现在你只需要知道，server_random到达了客户端。</p> <h3 id="step-3-client-验证证书-生成secret"><a href="#step-3-client-验证证书-生成secret" class="header-anchor">#</a> step 3: Client 验证证书，生成secret</h3> <p>客户端验证服务端传来的证书和签名是否通过，如果验证通过，则传递client_params这个参数给服务器。</p> <p>接着客户端通过ECDHE算法计算出pre_random，其中传入两个参数:server_params和client_params。现在你应该清楚这个两个参数的作用了吧，由于ECDHE基于椭圆曲线离散对数，这两个参数也称作椭圆曲线的公钥。</p> <p>客户端现在拥有了client_random、server_random和pre_random，接下来将这三个数通过一个伪随机数函数来计算出最终的secret。</p> <h3 id="step4-server-生成-secret"><a href="#step4-server-生成-secret" class="header-anchor">#</a> step4: Server 生成 secret</h3> <p>刚刚客户端不是传了client_params过来了吗？</p> <p>现在服务端开始用ECDHE算法生成pre_random，接着用和客户端同样的伪随机数函数生成最后的secret。</p> <h3 id="注意事项"><a href="#注意事项" class="header-anchor">#</a> 注意事项</h3> <p>TLS的过程基本上讲完了，但还有两点需要注意。</p> <p>第一、实际上 TLS 握手是一个双向认证的过程，从 step1 中可以看到，客户端有能力验证服务器的身份，那服务器能不能验证客户端的身份呢？</p> <p>当然是可以的。具体来说，在 step3中，客户端传送client_params，实际上给服务器传一个验证消息，让服务器将相同的验证流程(哈希摘要 + 私钥加密 + 公钥解密)走一遍，确认客户端的身份。</p> <p>第二、当客户端生成secret后，会给服务端发送一个收尾的消息，告诉服务器之后的都用对称加密，对称加密的算法就用第一次约定的。服务器生成完secret也会向客户端发送一个收尾的消息，告诉客户端以后就直接用对称加密来通信。</p> <p>这个收尾的消息包括两部分，一部分是Change Cipher Spec，意味着后面加密传输了，另一个是Finished消息，这个消息是对之前所有发送的数据做的摘要，对摘要进行加密，让对方验证一下。</p> <p>当双方都验证通过之后，握手才正式结束。后面的 HTTP 正式开始传输加密报文。</p> <h2 id="rsa-和-ecdhe-握手过程的区别"><a href="#rsa-和-ecdhe-握手过程的区别" class="header-anchor">#</a> RSA 和 ECDHE 握手过程的区别</h2> <ol><li><p>ECDHE 握手，也就是主流的 TLS1.2 握手中，使用ECDHE实现pre_random的加密解密，没有用到 RSA。</p></li> <li><p>使用 ECDHE 还有一个特点，就是客户端发送完收尾消息后可以提前抢跑，直接发送 HTTP 报文，节省了一个 RTT，不必等到收尾消息到达服务器，然后等服务器返回收尾消息给自己，直接开始发请求。这也叫TLS False Start。</p></li></ol> <h2 id="tls-1-3-做了哪些改进"><a href="#tls-1-3-做了哪些改进" class="header-anchor">#</a> TLS 1.3 做了哪些改进？</h2> <p>TLS 1.2 虽然存在了 10 多年，经历了无数的考验，但历史的车轮总是不断向前的，为了获得更强的安全、更优秀的性能，在2018年就推出了 TLS1.3，对于TLS1.2做了一系列的改进，主要分为这几个部分:强化安全、提高性能。</p> <h3 id="强化安全"><a href="#强化安全" class="header-anchor">#</a> 强化安全</h3> <p>在 TLS1.3 中废除了非常多的加密算法，最后只保留五个加密套件:</p> <ul><li>TLS_AES_128_GCM_SHA256</li> <li>TLS_AES_256_GCM_SHA384</li> <li>TLS_CHACHA20_POLY1305_SHA256</li> <li>TLS_AES_128_GCM_SHA256</li> <li>TLS_AES_128_GCM_8_SHA256</li></ul> <p>可以看到，最后剩下的对称加密算法只有 AES 和 CHACHA20，之前主流的也会这两种。分组模式也只剩下 GCM 和 POLY1305, 哈希摘要算法只剩下了 SHA256 和 SHA384 了。</p> <p>那你可能会问了, 之前RSA这么重要的非对称加密算法怎么不在了？</p> <p>我觉得有两方面的原因:</p> <p>第一、2015年发现了FREAK攻击，即已经有人发现了 RSA 的漏洞，能够进行破解了。</p> <p>第二、一旦私钥泄露，那么中间人可以通过私钥计算出之前所有报文的secret，破解之前所有的密文。</p> <p>为什么？回到 RSA 握手的过程中，客户端拿到服务器的证书后，提取出服务器的公钥，然后生成pre_random并用公钥加密传给服务器，服务器通过私钥解密，从而拿到真实的pre_random。当中间人拿到了服务器私钥，并且截获之前所有报文的时候，那么就能拿到pre_random、server_random和client_random并根据对应的随机数函数生成secret，也就是拿到了 TLS 最终的会话密钥，每一个历史报文都能通过这样的方式进行破解。</p> <p>但ECDHE在每次握手时都会生成临时的密钥对，即使私钥被破解，之前的历史消息并不会收到影响。这种一次破解并不影响历史信息的性质也叫前向安全性。</p> <p>RSA 算法不具备前向安全性，而 ECDHE 具备，因此在 TLS1.3 中彻底取代了RSA。</p> <h3 id="提升性能"><a href="#提升性能" class="header-anchor">#</a> 提升性能</h3> <h4 id="握手改进"><a href="#握手改进" class="header-anchor">#</a> 握手改进</h4> <p>流程如下:</p> <p><img src="/assets/img/3.13d2a002.jpg" alt="3"></p> <p>大体的方式和 TLS1.2 差不多，不过和 TLS 1.2 相比少了一个 RTT， 服务端不必等待对方验证证书之后才拿到client_params，而是直接在第一次握手的时候就能够拿到, 拿到之后立即计算secret，节省了之前不必要的等待时间。同时，这也意味着在第一次握手的时候客户端需要传送更多的信息，一口气给传完。</p> <p>这种 TLS 1.3 握手方式也被叫做1-RTT握手。但其实这种1-RTT的握手方式还是有一些优化的空间的，接下来我们来一一介绍这些优化方式。</p> <h4 id="会话复用"><a href="#会话复用" class="header-anchor">#</a> 会话复用</h4> <p>会话复用有两种方式: Session ID和Session Ticket。</p> <p>先说说最早出现的Seesion ID，具体做法是客户端和服务器首次连接后各自保存会话的 ID，并存储会话密钥，当再次连接时，客户端发送ID过来，服务器查找这个 ID 是否存在，如果找到了就直接复用之前的会话状态，会话密钥不用重新生成，直接用原来的那份。</p> <p>但这种方式也存在一个弊端，就是当客户端数量庞大的时候，对服务端的存储压力非常大。</p> <p>因而出现了第二种方式——Session Ticket。它的思路就是: 服务端的压力大，那就把压力分摊给客户端呗。具体来说，双方连接成功后，服务器加密会话信息，用Session Ticket消息发给客户端，让客户端保存下来。下次重连的时候，就把这个 Ticket 进行解密，验证它过没过期，如果没过期那就直接恢复之前的会话状态。</p> <p>这种方式虽然减小了服务端的存储压力，但与带来了安全问题，即每次用一个固定的密钥来解密 Ticket 数据，一旦黑客拿到这个密钥，之前所有的历史记录也被破解了。因此为了尽量避免这样的问题，密钥需要定期进行更换。</p> <p>总的来说，这些会话复用的技术在保证1-RTT的同时，也节省了生成会话密钥这些算法所消耗的时间，是一笔可观的性能提升。</p> <h4 id="psk"><a href="#psk" class="header-anchor">#</a> PSK</h4> <p>刚刚说的都是1-RTT情况下的优化，那能不能优化到0-RTT呢？</p> <p>答案是可以的。做法其实也很简单，在发送Session Ticket的同时带上应用数据，不用等到服务端确认，这种方式被称为Pre-Shared Key，即 PSK。</p> <p>这种方式虽然方便，但也带来了安全问题。中间人截获PSK的数据，不断向服务器重复发，类似于 TCP 第一次握手携带数据，增加了服务器被攻击的风险</p> <h4 id="总结-2"><a href="#总结-2" class="header-anchor">#</a> 总结</h4> <p>TLS1.3 在 TLS1.2 的基础上废除了大量的算法，提升了安全性。同时利用会话复用节省了重新生成密钥的时间，利用 PSK 做到了0-RTT连接。</p> <h2 id="参考"><a href="#参考" class="header-anchor">#</a> 参考</h2> <p><a href="https://blog.csdn.net/qq_38975553/article/details/112987893" target="_blank" rel="noopener noreferrer">HTTPS(TLS1.2连接过程解析 - 基于ECDHE密钥交换算法)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/networkprotocol/http/011/" class="prev">
        如何理解 HTTP 代理？
      </a></span> <span class="next"><a href="/networkprotocol/http/013/">
        HTTP2
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.7faaeb90.js" defer></script><script src="/assets/js/2.4ceac094.js" defer></script><script src="/assets/js/1.06e97743.js" defer></script><script src="/assets/js/26.b6ea8fe3.js" defer></script>
  </body>
</html>

(window.webpackJsonp=window.webpackJsonp||[]).push([[125],{485:function(t,s,a){"use strict";a.r(s);var e=a(10),r=Object(e.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"react-hooks-和-class-组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react-hooks-和-class-组件"}},[t._v("#")]),t._v(" React hooks 和 class 组件")]),t._v(" "),s("h2",{attrs:{id:"hoc-高阶组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hoc-高阶组件"}},[t._v("#")]),t._v(" HOC 高阶组件")]),t._v(" "),s("h2",{attrs:{id:"hooks"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hooks"}},[t._v("#")]),t._v(" hooks")]),t._v(" "),s("h3",{attrs:{id:"优点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[t._v("#")]),t._v(" 优点：")]),t._v(" "),s("ol",[s("li",[t._v("更容易复用代码")])]),t._v(" "),s("p",[t._v("hooks复用比高阶组件复用逻辑更容易维护，class 生命周期比较复杂。")]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[t._v("更加清爽的代码风格+代码量更少")])]),t._v(" "),s("h3",{attrs:{id:"缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[t._v("#")]),t._v(" 缺点：")]),t._v(" "),s("ol",[s("li",[t._v("响应式的useEffect")])]),t._v(" "),s("p",[t._v("写函数组件时，你不得不改变一些写法习惯。你必须清楚代码中useEffect和useCallback的“依赖项数组”的改变时机。有时候，你的useEffect依赖某个函数的不可变性，这个函数的不可变性又依赖于另一个函数的不可变性，这样便形成了一条依赖链。一旦这条依赖链的某个节点意外地被改变了，你的useEffect就被意外地触发了，如果你的useEffect是幂等的操作，可能带来的是性能层次的问题，如果是非幂等，那就糟糕了。")]),t._v(" "),s("p",[t._v("所以，对比componentDidmount和componentDidUpdate，useEffect带来的心智负担更大。")]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[t._v("状态不同步")])]),t._v(" "),s("h2",{attrs:{id:"参考"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),s("p",[t._v("https://github.com/KieSun/Dream/issues/15")]),t._v(" "),s("p",[t._v("[谈谈react hooks的优缺点")]),t._v(" "),s("p",[t._v("Yong_bcf4\n](https://www.jianshu.com/p/d5e4aa1a568d)")])])}),[],!1,null,null,null);s.default=r.exports}}]);
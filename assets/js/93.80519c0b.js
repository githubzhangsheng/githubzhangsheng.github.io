(window.webpackJsonp=window.webpackJsonp||[]).push([[93],{516:function(a,t,r){"use strict";r.r(t);var e=r(24),s=Object(e.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"如何理解-http-代理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如何理解-http-代理"}},[a._v("#")]),a._v(" 如何理解 HTTP 代理？")]),a._v(" "),r("p",[a._v("我们知道在 HTTP 是基于请求-响应模型的协议，一般由客户端发请求，服务器来进行响应。")]),a._v(" "),r("p",[a._v("当然，也有特殊情况，就是代理服务器的情况。引入代理之后，作为代理的服务器相当于一个中间人的角色，对于客户端而言，表现为服务器进行响应；而对于源服务器，表现为客户端发起请求，具有双重身份。")]),a._v(" "),r("p",[a._v("那代理服务器到底是用来做什么的呢？")]),a._v(" "),r("h2",{attrs:{id:"功能"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#功能"}},[a._v("#")]),a._v(" 功能")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("1.负载均衡。客户端的请求只会先到达代理服务器，后面到底有多少源服务器，IP 都是多少，客户端是不知道的。因此，这个代理服务器可以拿到这个请求之后，可以通过特定的算法分发给不同的源服务器，让各台源服务器的负载尽量平均。当然，这样的算法有很多，包括随机算法、轮询、一致性hash、LRU(最近最少使用)等等，不过这些算法并不是本文的重点，大家有兴趣自己可以研究一下。")])]),a._v(" "),r("li",[r("ol",{attrs:{start:"2"}},[r("li",[a._v("保障安全。利用心跳机制监控后台的服务器，一旦发现故障机就将其踢出集群。并且对于上下行的数据进行过滤，对非法 IP 限流，这些都是代理服务器的工作。")])])])]),a._v(" "),r("p",[a._v("缓存代理。将内容缓存到代理服务器，使得客户端可以直接从代理服务器获得而不用到源服务器那里。下一节详细拆解。")]),a._v(" "),r("ul",[r("li",[a._v("3.缓存代理。将内容缓存到代理服务器，使得客户端可以直接从代理服务器获得而不用到源服务器那里。")])]),a._v(" "),r("h2",{attrs:{id:"相关头部字段"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#相关头部字段"}},[a._v("#")]),a._v(" 相关头部字段")]),a._v(" "),r("h3",{attrs:{id:"via"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#via"}},[a._v("#")]),a._v(" Via")]),a._v(" "),r("p",[a._v("代理服务器需要标明自己的身份，在 HTTP 传输中留下自己的痕迹，怎么办呢？")]),a._v(" "),r("p",[a._v("通过Via字段来记录。举个例子，现在中间有两台代理服务器，在客户端发送请求后会经历这样一个过程:")]),a._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v("客户端 -> 代理1 -> 代理2 -> 源服务器\n")])])]),r("p",[a._v("在源服务器收到请求后，会在请求头拿到这个字段:")]),a._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v("Via: proxy_server1, proxy_server2\n")])])]),r("p",[a._v("而源服务器响应时，最终在客户端会拿到这样的响应头:")]),a._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v("Via: proxy_server2, proxy_server1\n")])])]),r("p",[a._v("可以看到，Via中代理的顺序即为在 HTTP 传输中报文传达的顺序。")]),a._v(" "),r("h3",{attrs:{id:"x-forwarded-for"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#x-forwarded-for"}},[a._v("#")]),a._v(" X-Forwarded-For")]),a._v(" "),r("p",[a._v("字面意思就是为谁转发, 它记录的是请求方的IP地址(注意，和Via区分开，X-Forwarded-For记录的是请求方这一个IP)。")]),a._v(" "),r("h3",{attrs:{id:"x-real-ip"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#x-real-ip"}},[a._v("#")]),a._v(" X-Real-IP")]),a._v(" "),r("p",[a._v("是一种获取用户真实 IP 的字段，不管中间经过多少代理，这个字段始终记录最初的客户端的IP。")]),a._v(" "),r("p",[a._v("相应的，还有X-Forwarded-Host和X-Forwarded-Proto，分别记录客户端(注意哦，不包括代理)的域名和协议名。")]),a._v(" "),r("h2",{attrs:{id:"缓存代理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#缓存代理"}},[a._v("#")]),a._v(" 缓存代理")]),a._v(" "),r("h3",{attrs:{id:"为什么产生代理缓存"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么产生代理缓存"}},[a._v("#")]),a._v(" 为什么产生代理缓存？")]),a._v(" "),r("p",[a._v("对于源服务器来说，它也是有缓存的，比如Redis, Memcache，但对于 HTTP 缓存来说，如果每次客户端缓存失效都要到源服务器获取，那给源服务器的压力是很大的。")]),a._v(" "),r("p",[a._v("由此引入了缓存代理的机制。让代理服务器接管一部分的服务端HTTP缓存，客户端缓存过期后就近到代理缓存中获取，代理缓存过期了才请求源服务器，这样流量巨大的时候能明显降低源服务器的压力。")]),a._v(" "),r("p",[a._v("那缓存代理究竟是如何做到的呢？")]),a._v(" "),r("p",[a._v("总的来说，缓存代理的控制分为两部分，一部分是源服务器端的控制，一部分是客户端的控制。")]),a._v(" "),r("h2",{attrs:{id:"源服务器的缓存控制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#源服务器的缓存控制"}},[a._v("#")]),a._v(" 源服务器的缓存控制")]),a._v(" "),r("h3",{attrs:{id:"private-和-public"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#private-和-public"}},[a._v("#")]),a._v(" private 和 public")]),a._v(" "),r("p",[a._v("在源服务器的响应头中，会加上Cache-Control这个字段进行缓存控制字段，那么它的值当中可以加入private或者public表示是否允许代理服务器缓存，前者禁止，后者为允许。")]),a._v(" "),r("p",[a._v("比如对于一些非常私密的数据，如果缓存到代理服务器，别人直接访问代理就可以拿到这些数据，是非常危险的，因此对于这些数据一般是不会允许代理服务器进行缓存的，将响应头部的Cache-Control设为private，而不是public。")]),a._v(" "),r("h3",{attrs:{id:"proxy-revalidate"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#proxy-revalidate"}},[a._v("#")]),a._v(" proxy-revalidate")]),a._v(" "),r("p",[a._v("must-revalidate的意思是客户端缓存过期就去源服务器获取，而proxy-revalidate则表示代理服务器的缓存过期后到源服务器获取。")]),a._v(" "),r("h3",{attrs:{id:"s-maxage"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#s-maxage"}},[a._v("#")]),a._v(" s-maxage")]),a._v(" "),r("p",[a._v("s是share的意思，限定了缓存在代理服务器中可以存放多久，和限制客户端缓存时间的max-age并不冲突。")]),a._v(" "),r("p",[a._v("讲了这几个字段，我们不妨来举个小例子，源服务器在响应头中加入这样一个字段:")]),a._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[a._v("Cache-Control: public, max-age=1000, s-maxage=200\n")])])]),r("p",[a._v("相当于源服务器说: 我这个响应是允许代理服务器缓存的，客户端缓存过期了到代理中拿，并且在客户端的缓存时间为 1000 秒，在代理服务器中的缓存时间为 2000s。")]),a._v(" "),r("h2",{attrs:{id:"客户端的缓存控制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#客户端的缓存控制"}},[a._v("#")]),a._v(" 客户端的缓存控制")]),a._v(" "),r("h3",{attrs:{id:"max-stale-和-min-fresh"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#max-stale-和-min-fresh"}},[a._v("#")]),a._v(" max-stale 和 min-fresh")]),a._v(" "),r("p",[a._v("在客户端的请求头中，可以加入这两个字段，来对代理服务器上的缓存进行宽容和限制操作。比如：")]),a._v(" "),r("p",[a._v("max-stale: 5")]),a._v(" "),r("p",[a._v("表示客户端到代理服务器上拿缓存的时候，即使代理缓存过期了也不要紧，只要过期时间在5秒之内，还是可以从代理中获取的。")]),a._v(" "),r("p",[a._v("又比如:")]),a._v(" "),r("p",[a._v("min-fresh: 5")]),a._v(" "),r("p",[a._v("表示代理缓存需要一定的新鲜度，不要等到缓存刚好到期再拿，一定要在到期前 5 秒之前的时间拿，否则拿不到。")]),a._v(" "),r("h3",{attrs:{id:"only-if-cached"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#only-if-cached"}},[a._v("#")]),a._v(" only-if-cached")]),a._v(" "),r("p",[a._v("这个字段加上后表示客户端只会接受代理缓存，而不会接受源服务器的响应。如果代理缓存无效，则直接返回504（Gateway Timeout）。")]),a._v(" "),r("p",[a._v("以上便是缓存代理的内容，涉及的字段比较多，希望能好好回顾一下，加深理解。")])])}),[],!1,null,null,null);t.default=s.exports}}]);
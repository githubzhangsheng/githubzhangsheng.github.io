(window.webpackJsonp=window.webpackJsonp||[]).push([[114],{557:function(t,e,a){"use strict";a.r(e);var r=a(24),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"vue3-diff-算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue3-diff-算法"}},[t._v("#")]),t._v(" Vue3 Diff 算法")]),t._v(" "),a("h2",{attrs:{id:"patch"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#patch"}},[t._v("#")]),t._v(" patch")]),t._v(" "),a("p",[t._v("在 Vue update 的过程中，在遍历子代 Vnode 的时候，会用不同的 patch 方法来更新老的 VNode, 如果找到 newVnode 和 oldNode 相对应，就可以复用之前的 oldNode 中已渲染的真实 DOM 节点。避免重复创建元素带来的性能开销。毕竟浏览器创建真实的 DOM，性能代价是昂贵的。")]),t._v(" "),a("h2",{attrs:{id:"vue2-和-vue3-diff-对比"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue2-和-vue3-diff-对比"}},[t._v("#")]),t._v(" Vue2 和 Vue3 Diff 对比")]),t._v(" "),a("h3",{attrs:{id:"compile-过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#compile-过程"}},[t._v("#")]),t._v(" compile 过程")]),t._v(" "),a("p",[t._v("vue2：start => parse(生成 AST) => optimize (遍历 AST ，对每个 AST Element 进行标识 static 和 staticRoot) => generate(根据优化后的 AST，生成对应的可执行函数) => 结束。")]),t._v(" "),a("p",[t._v("vue3: start => baseParse(词法分析，生成 AST) => tranform (遍历 AST，对每一个 AST Element 进行优化，例如文本元素、指令元素、动态元素的转化) => generate (根据转化后的 AST，生成对应的可执行函数)")]),t._v(" "),a("h3",{attrs:{id:"parse-和-baseparse"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parse-和-baseparse"}},[t._v("#")]),t._v(" parse 和 baseParse")]),t._v(" "),a("p",[t._v("构建原始抽象语法树(AST), 解析 template 生成原始的 AST, vue3 的语法树比 vue2 多出几个属性，hoists、helpers、codegenNode 等等。")]),t._v(" "),a("h3",{attrs:{id:"optimize-和-tranform"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#optimize-和-tranform"}},[t._v("#")]),t._v(" optimize 和 tranform")]),t._v(" "),a("h4",{attrs:{id:"tranform"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tranform"}},[t._v("#")]),t._v(" tranform")]),t._v(" "),a("p",[t._v("tranformText、tranformElement、")]),t._v(" "),a("h4",{attrs:{id:"静态节点提升"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#静态节点提升"}},[t._v("#")]),t._v(" 静态节点提升")]),t._v(" "),a("p",[t._v("vue3 对于静态节点在整个生命周期中只会执行【一次创建】，这在一定程度上降低了性能上的开销。")]),t._v(" "),a("p",[t._v("vue3.x 中标记和提升所有的静态节点，diff 的时候只需要对比动态节点内容")]),t._v(" "),a("h3",{attrs:{id:"generate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#generate"}},[t._v("#")]),t._v(" generate")]),t._v(" "),a("h2",{attrs:{id:"diff过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#diff过程"}},[t._v("#")]),t._v(" DIFF过程")]),t._v(" "),a("p",[t._v("元素比较 => 儿子节点比较 => 儿子节点都为数组，同层比较")]),t._v(" "),a("p",[t._v("从头开始比较\n从尾开始比较\n同序列加挂载\n同序列加卸载")]),t._v(" "),a("h3",{attrs:{id:"未知序列对比"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#未知序列对比"}},[t._v("#")]),t._v(" 未知序列对比")]),t._v(" "),a("ul",[a("li",[t._v("构建映射表")]),t._v(" "),a("li",[t._v("查找原先子节点是否存在可复用的")]),t._v(" "),a("li",[t._v("节点移动和复用（最长递增子序列）")])]),t._v(" "),a("h2",{attrs:{id:"参考文章"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[t._v("#")]),t._v(" 参考文章")]),t._v(" "),a("p",[t._v("https://zhuanlan.zhihu.com/p/150103393")]),t._v(" "),a("p",[t._v("https://blog.csdn.net/weixin_35625397/article/details/112130142")]),t._v(" "),a("p",[t._v("https://www.6hu.cc/archives/3193.html")]),t._v(" "),a("p",[t._v("https://zhuanlan.zhihu.com/p/150732926?from_voters_page=true")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/357923422",target:"_blank",rel:"noopener noreferrer"}},[t._v("vue3的diff实现原理"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"https://blog.csdn.net/webyouxuan/article/details/108414286",target:"_blank",rel:"noopener noreferrer"}},[t._v("Vue3的getSequence最长上升子序列"),a("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=s.exports}}]);
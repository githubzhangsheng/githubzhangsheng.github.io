(window.webpackJsonp=window.webpackJsonp||[]).push([[81],{498:function(t,a,s){"use strict";s.r(a);var e=s(24),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"http1-1-如何解决-http-的队头阻塞问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http1-1-如何解决-http-的队头阻塞问题"}},[t._v("#")]),t._v(" HTTP1.1 如何解决 HTTP 的队头阻塞问题？")]),t._v(" "),s("h2",{attrs:{id:"什么是-http-队头阻塞"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是-http-队头阻塞"}},[t._v("#")]),t._v(" 什么是 HTTP 队头阻塞？")]),t._v(" "),s("p",[t._v("从前面的小节可以知道，HTTP 传输是基于请求-应答的模式进行的，报文必须是一发一收，但值得注意的是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是著名的HTTP队头阻塞问题。")]),t._v(" "),s("h2",{attrs:{id:"并发连接"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#并发连接"}},[t._v("#")]),t._v(" 并发连接")]),t._v(" "),s("p",[t._v("对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。在RFC2616规定过客户端最多并发 2 个连接，不过事实上在现在的浏览器标准中，这个上限要多很多，Chrome 中是 6 个。")]),t._v(" "),s("p",[t._v("但其实，即使是提高了并发连接，还是不能满足人们对性能的需求。")]),t._v(" "),s("h2",{attrs:{id:"域名分片"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#域名分片"}},[t._v("#")]),t._v(" 域名分片")]),t._v(" "),s("p",[t._v("一个域名不是可以并发 6 个长连接吗？那我就多分几个域名。")]),t._v(" "),s("p",[t._v("比如 content1.test.com 、content2.test.com。")]),t._v(" "),s("p",[t._v("这样一个 test.com域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。")])])}),[],!1,null,null,null);a.default=r.exports}}]);